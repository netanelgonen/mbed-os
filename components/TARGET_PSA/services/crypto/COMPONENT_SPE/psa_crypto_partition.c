/* Copyright (c) 2017-2018 ARM Limited
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/***********************************************************************************************************************
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * THIS FILE IS AN AUTO-GENERATED FILE - DO NOT MODIFY IT.
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * Template Version 1.0
 * Generated by tools/spm/generate_partition_code.py Version 1.0
 **********************************************************************************************************************/

#include "cmsis.h"
#include "mbed_toolchain.h" /* For using MBED_ALIGN macro */
#include "rtx_os.h"
#include "spm_panic.h"
<<<<<<< HEAD
#include "spm_internal.h"
#include "psa_crypto_partition.h"
#include "psa_crypto_ifs.h"
#include "psa_its_ifs.h"


/* Threads stacks */
MBED_ALIGN(8) uint8_t crypto_thread_stack[16384] = {0};

/* Threads control blocks */
osRtxThread_t crypto_thread_cb = {0};

/* Thread attributes - for thread initialization */
osThreadAttr_t crypto_thread_attr = {
    .name = "crypto",
    .attr_bits = 0,
    .cb_mem = &crypto_thread_cb,
    .cb_size = sizeof(crypto_thread_cb),
    .stack_mem = crypto_thread_stack,
    .stack_size = 16384,
    .priority = osPriorityNormal,
    .tz_module = 0,
    .reserved = 0
};

spm_rot_service_t crypto_rot_services[CRYPTO_ROT_SRV_COUNT] = {
    {
        .sid = PSA_CRYPTO_INIT_ID,
        .mask = PSA_CRYPTO_INIT,
        .partition = NULL,
        .min_version = 1,
        .min_version_policy = PSA_MINOR_VERSION_POLICY_STRICT,
        .allow_nspe = true,
        .queue = {
            .head = NULL,
            .tail = NULL
        }
    },
    {
        .sid = PSA_MAC_ID,
        .mask = PSA_MAC,
        .partition = NULL,
        .min_version = 1,
        .min_version_policy = PSA_MINOR_VERSION_POLICY_STRICT,
        .allow_nspe = true,
        .queue = {
            .head = NULL,
            .tail = NULL
        }
    },
    {
        .sid = PSA_HASH_ID,
        .mask = PSA_HASH,
        .partition = NULL,
        .min_version = 1,
        .min_version_policy = PSA_MINOR_VERSION_POLICY_STRICT,
        .allow_nspe = true,
        .queue = {
            .head = NULL,
            .tail = NULL
        }
    },
    {
        .sid = PSA_ASYMMETRIC_ID,
        .mask = PSA_ASYMMETRIC,
        .partition = NULL,
        .min_version = 1,
        .min_version_policy = PSA_MINOR_VERSION_POLICY_STRICT,
        .allow_nspe = true,
        .queue = {
            .head = NULL,
            .tail = NULL
        }
    },
    {
        .sid = PSA_SYMMETRIC_ID,
        .mask = PSA_SYMMETRIC,
        .partition = NULL,
        .min_version = 1,
        .min_version_policy = PSA_MINOR_VERSION_POLICY_STRICT,
        .allow_nspe = true,
        .queue = {
            .head = NULL,
            .tail = NULL
        }
    },
    {
        .sid = PSA_AEAD_ID,
        .mask = PSA_AEAD,
        .partition = NULL,
        .min_version = 1,
        .min_version_policy = PSA_MINOR_VERSION_POLICY_STRICT,
        .allow_nspe = true,
        .queue = {
            .head = NULL,
            .tail = NULL
        }
    },
    {
        .sid = PSA_KEY_MNG_ID,
        .mask = PSA_KEY_MNG,
        .partition = NULL,
        .min_version = 1,
        .min_version_policy = PSA_MINOR_VERSION_POLICY_STRICT,
        .allow_nspe = true,
        .queue = {
            .head = NULL,
            .tail = NULL
        }
    },
    {
        .sid = PSA_RNG_ID,
        .mask = PSA_RNG,
        .partition = NULL,
        .min_version = 1,
        .min_version_policy = PSA_MINOR_VERSION_POLICY_STRICT,
        .allow_nspe = true,
        .queue = {
            .head = NULL,
            .tail = NULL
        }
    },
    {
        .sid = PSA_CRYPTO_FREE_ID,
        .mask = PSA_CRYPTO_FREE,
        .partition = NULL,
        .min_version = 1,
        .min_version_policy = PSA_MINOR_VERSION_POLICY_STRICT,
        .allow_nspe = true,
        .queue = {
            .head = NULL,
            .tail = NULL
        }
    },
    {
        .sid = PSA_GENERATOR_ID,
        .mask = PSA_GENERATOR,
        .partition = NULL,
        .min_version = 1,
        .min_version_policy = PSA_MINOR_VERSION_POLICY_STRICT,
        .allow_nspe = true,
        .queue = {
            .head = NULL,
            .tail = NULL
        }
    },
    {
        .sid = PSA_ENTROPY_ID,
        .mask = PSA_ENTROPY_INJECT,
        .partition = NULL,
        .min_version = 1,
        .min_version_policy = PSA_MINOR_VERSION_POLICY_STRICT,
        .allow_nspe = true,
        .queue = {
            .head = NULL,
            .tail = NULL
        }
    },
};

/* External SIDs used by CRYPTO */
const uint32_t crypto_external_sids[4] = {
    PSA_ITS_GET,
    PSA_ITS_SET,
    PSA_ITS_INFO,
    PSA_ITS_REMOVE,
};

static osRtxMutex_t crypto_mutex = {0};
static const osMutexAttr_t crypto_mutex_attr = {
    .name = "crypto_mutex",
    .attr_bits = osMutexRecursive | osMutexPrioInherit | osMutexRobust,
    .cb_mem = &crypto_mutex,
    .cb_size = sizeof(crypto_mutex),
};


extern void crypto_main(void *ptr);

void crypto_init(spm_partition_t *partition)
=======
#include "spm_server.h"
#include "spm/psa_defs.h"
#include "spm/spm_client.h"

#define PSA_CRYPTO_SECURE 1
#include "crypto_spe.h"
#include "crypto_platform_spe.h"
#include "psa_psa_f_partition.h"
#include "mbedtls/entropy.h"

#if defined(MBEDTLS_PLATFORM_C)
#include "mbedtls/platform.h"
#else
#define mbedtls_calloc calloc
#define mbedtls_free   free
#endif
// ------------------------- Globals ---------------------------
static int psa_spm_init_refence_counter = 0;

// ------------------------- Partition's Main Thread ---------------------------
static void psa_crypto_init_operation(void)
{
    psa_msg_t msg = { 0 };
    psa_status_t status = PSA_SUCCESS;

    psa_get(PSA_CRYPTO_INIT, &msg);

    switch (msg.type) {
        case PSA_IPC_CONNECT:
        case PSA_IPC_DISCONNECT: {
            break;
        }

        case PSA_IPC_CALL: {
            status = psa_crypto_init();
            if (status == PSA_SUCCESS) {
                ++psa_spm_init_refence_counter;
            }
            break;
        }

        default: {
            status = PSA_ERROR_NOT_SUPPORTED;
            break;
        }
    }
    psa_reply(msg.handle, (psa_error_t) status);
}

static void psa_crypto_free_operation(void)
{
    psa_msg_t msg = { 0 };
    psa_status_t status = PSA_SUCCESS;

    psa_get(PSA_CRYPTO_FREE, &msg);

    switch (msg.type) {
        case PSA_IPC_CONNECT:
        case PSA_IPC_DISCONNECT: {
            break;
        }

        case PSA_IPC_CALL: {
            /** perform crypto_free iff the number of init-s
             * is equal to the number of free-s
             */
            --psa_spm_init_refence_counter;
            if (!psa_spm_init_refence_counter) {
                mbedtls_psa_crypto_free();
            }
            break;
        }

        default: {
            status = PSA_ERROR_NOT_SUPPORTED;
            break;
        }
    }
    psa_reply(msg.handle, (psa_error_t) status);
}

static void psa_mac_operation(void)
{
    psa_msg_t msg = { 0 };
    psa_status_t status = PSA_SUCCESS;

    psa_get(PSA_MAC, &msg);

    switch (msg.type) {
        case PSA_IPC_CONNECT: {
            psa_mac_operation_t *psa_operation = mbedtls_calloc(1, sizeof(psa_mac_operation_t));
            if (psa_operation == NULL) {
                status = PSA_ERROR_INSUFFICIENT_MEMORY;
                break;
            }
            psa_set_rhandle(msg.handle, psa_operation);
            break;
        }

        case PSA_IPC_CALL: {
            uint32_t bytes_read;
            psa_crypto_ipc_t psa_crypto = { 0 };

            if (msg.in_size[0] != sizeof(psa_crypto_ipc_t)) {
                status = PSA_ERROR_COMMUNICATION_FAILURE;
                break;
            }

            bytes_read = psa_read(msg.handle, 0, &psa_crypto, msg.in_size[0]);

            if (bytes_read != msg.in_size[0]) {
                SPM_PANIC("SPM read length mismatch");
            }

            switch (psa_crypto.func) {
                case PSA_MAC_SIGN_SETUP: {
                    status = psa_mac_sign_setup(msg.rhandle,
                                                psa_crypto.key,
                                                psa_crypto.alg);
                    break;
                }

                case PSA_MAC_VERIFY_SETUP: {
                    status = psa_mac_verify_setup(msg.rhandle,
                                                  psa_crypto.key,
                                                  psa_crypto.alg);
                    break;
                }

                case PSA_MAC_UPDATE: {
                    uint8_t *input_ptr = mbedtls_calloc(1, msg.in_size[1]);
                    if (input_ptr == NULL) {
                        status = PSA_ERROR_INSUFFICIENT_MEMORY;
                        break;
                    }
                    bytes_read = psa_read(msg.handle, 1, input_ptr,
                                          msg.in_size[1]);

                    if (bytes_read != msg.in_size[1]) {
                        SPM_PANIC("SPM read length mismatch");
                    }

                    status = psa_mac_update(msg.rhandle,
                                            input_ptr,
                                            msg.in_size[1]);

                    mbedtls_free(input_ptr);
                    break;
                }

                case PSA_MAC_SIGN_FINISH: {
                    size_t mac_size = 0;
                    bytes_read = psa_read(msg.handle, 1, &mac_size,
                                          msg.in_size[1]);
                    if (bytes_read != msg.in_size[1]) {
                        SPM_PANIC("SPM read length mismatch");
                    }

                    size_t mac_length = 0;
                    uint8_t *mac = mbedtls_calloc(1, mac_size);
                    if (mac == NULL) {
                        status = PSA_ERROR_INSUFFICIENT_MEMORY;
                        break;
                    }
                    status = psa_mac_sign_finish(msg.rhandle, mac, mac_size,
                                                 &mac_length);

                    if (status == PSA_SUCCESS) {
                        psa_write(msg.handle, 0, mac, mac_length);
                        psa_write(msg.handle, 1, &mac_length,
                                  sizeof(mac_length));
                    }
                    mbedtls_free(mac);
                    break;
                }
                case PSA_MAC_VERIFY_FINISH: {
                    size_t mac_length = 0;
                    bytes_read = psa_read(msg.handle, 1, &mac_length,
                                          msg.in_size[1]);
                    if (bytes_read != msg.in_size[1] ||
                            mac_length != msg.in_size[2]) {
                        SPM_PANIC("SPM read length mismatch");
                    }
                    uint8_t *mac = mbedtls_calloc(1, mac_length);
                    if (mac == NULL) {
                        status = PSA_ERROR_INSUFFICIENT_MEMORY;
                        break;
                    }
                    bytes_read = psa_read(msg.handle, 2, mac, msg.in_size[2]);
                    if (bytes_read != msg.in_size[2]) {
                        SPM_PANIC("SPM read length mismatch");
                    }
                    status = psa_mac_verify_finish(msg.rhandle, mac, mac_length);
                    mbedtls_free(mac);
                    break;
                }
                case PSA_MAC_ABORT: {
                    status = psa_mac_abort(msg.rhandle);
                    break;
                }
                default: {
                    status = PSA_ERROR_NOT_SUPPORTED;
                    break;
                }
                break;
            }
            break;
        }
        case PSA_IPC_DISCONNECT: {
            psa_mac_abort(msg.rhandle);
            if (msg.rhandle != NULL) {
                mbedtls_free(msg.rhandle);
            }
            break;
        }
        default: {
            status = PSA_ERROR_NOT_SUPPORTED;
            break;
        }
    }
    psa_reply(msg.handle, (psa_error_t) status);
}


static void psa_hash_operation(void)
{
    psa_msg_t msg = { 0 };
    psa_status_t status = PSA_SUCCESS;

    psa_get(PSA_HASH, &msg);

    switch (msg.type) {
        case PSA_IPC_CONNECT: {
            psa_hash_operation_t *psa_operation = mbedtls_calloc(1, sizeof(psa_hash_operation_t));
            if (psa_operation == NULL) {
                status = PSA_ERROR_INSUFFICIENT_MEMORY;
                break;
            }
            psa_set_rhandle(msg.handle, psa_operation);
            break;
        }

        case PSA_IPC_CALL: {
            uint32_t bytes_read = 0;
            psa_crypto_ipc_t psa_crypto = {0};

            if (msg.in_size[0] != sizeof(psa_crypto_ipc_t)) {
                status = PSA_ERROR_COMMUNICATION_FAILURE;
                break;
            }

            bytes_read = psa_read(msg.handle, 0, &psa_crypto, msg.in_size[0]);

            if (bytes_read != msg.in_size[0]) {
                SPM_PANIC("SPM read length mismatch");
            }

            switch (psa_crypto.func) {
                case PSA_HASH_SETUP: {
                    status = psa_hash_setup(msg.rhandle,
                                            psa_crypto.alg);
                    break;
                }

                case PSA_HASH_UPDATE: {
                    uint8_t *input_ptr = mbedtls_calloc(1, msg.in_size[1]);
                    if (input_ptr == NULL) {
                        status = PSA_ERROR_INSUFFICIENT_MEMORY;
                        break;
                    }
                    bytes_read = psa_read(msg.handle, 1, input_ptr,
                                          msg.in_size[1]);

                    if (bytes_read != msg.in_size[1]) {
                        SPM_PANIC("SPM read length mismatch");
                    }

                    status = psa_hash_update(msg.rhandle,
                                             input_ptr,
                                             msg.in_size[1]);
                    mbedtls_free(input_ptr);
                    break;
                }

                case PSA_HASH_FINISH: {
                    size_t hash_size = 0;
                    bytes_read = psa_read(msg.handle, 1, &hash_size,
                                          msg.in_size[1]);
                    if (bytes_read != msg.in_size[1]) {
                        SPM_PANIC("SPM read length mismatch");
                    }
                    size_t hash_length = 0;
                    uint8_t *hash = mbedtls_calloc(1, hash_size);
                    if (hash == NULL) {
                        status = PSA_ERROR_INSUFFICIENT_MEMORY;
                        break;
                    }
                    status = psa_hash_finish(msg.rhandle, hash, hash_size,
                                             &hash_length);

                    if (status == PSA_SUCCESS) {
                        psa_write(msg.handle, 0, hash, hash_length);
                        psa_write(msg.handle, 1, &hash_length,
                                  sizeof(hash_length));
                    }

                    mbedtls_free(hash);
                    break;
                }
                case PSA_HASH_VERIFY: {
                    size_t hash_length = 0;
                    bytes_read = psa_read(msg.handle, 1, &hash_length,
                                          msg.in_size[1]);
                    if (bytes_read != msg.in_size[1] ||
                            hash_length != msg.in_size[2]) {
                        SPM_PANIC("SPM read length mismatch");
                    }
                    uint8_t *hash = mbedtls_calloc(1, hash_length);
                    if (hash == NULL) {
                        status = PSA_ERROR_INSUFFICIENT_MEMORY;
                        break;
                    }
                    bytes_read = psa_read(msg.handle, 2, hash, msg.in_size[2]);
                    if (bytes_read != msg.in_size[2]) {
                        SPM_PANIC("SPM read length mismatch");
                    }
                    status = psa_hash_verify(msg.rhandle, hash, hash_length);
                    mbedtls_free(hash);
                    break;
                }
                case PSA_HASH_ABORT: {
                    status = psa_hash_abort(msg.rhandle);
                    break;
                }
                default: {
                    status = PSA_ERROR_NOT_SUPPORTED;
                    break;
                }
            }
            break;
        }
        case PSA_IPC_DISCONNECT: {
            psa_hash_abort(msg.rhandle);
            if (msg.rhandle != NULL) {
                mbedtls_free(msg.rhandle);
            }
            break;
        }
        default: {
            status = PSA_ERROR_INSUFFICIENT_MEMORY;
            break;
        }
    }

    psa_reply(msg.handle, status);
}

static void psa_asymmetric_operation(void)
{
    psa_msg_t msg = { 0 };
    psa_status_t status = PSA_SUCCESS;

    psa_get(PSA_ASYMMETRIC, &msg);

    switch (msg.type) {
        case PSA_IPC_CONNECT:
            break;

        case PSA_IPC_CALL: {
            if (msg.in_size[0] != sizeof(psa_crypto_ipc_asymmetric_t)) {
                status = PSA_ERROR_COMMUNICATION_FAILURE;
                break;
            }

            uint32_t bytes_read = 0;
            psa_crypto_ipc_asymmetric_t psa_crypto = {0};

            bytes_read = psa_read(msg.handle, 0, &psa_crypto, msg.in_size[0]);

            if (bytes_read != msg.in_size[0]) {
                SPM_PANIC("SPM read length mismatch");
            }

            switch (psa_crypto.func) {
                case PSA_ASYMMETRIC_SIGN: {
                    uint8_t *signature;
                    uint8_t *hash;
                    size_t signature_length = 0;

                    signature = mbedtls_calloc(1, msg.out_size[0]);
                    if (signature == NULL) {
                        status = PSA_ERROR_INSUFFICIENT_MEMORY;
                        break;
                    }

                    hash = mbedtls_calloc(1, msg.in_size[1]);
                    if (hash == NULL) {
                        status = PSA_ERROR_INSUFFICIENT_MEMORY;
                        mbedtls_free(signature);
                        break;
                    }

                    bytes_read = psa_read(msg.handle, 1,
                                          hash, msg.in_size[1]);
                    if (bytes_read != msg.in_size[1]) {
                        SPM_PANIC("SPM read length mismatch");
                    }
                    status = psa_asymmetric_sign(psa_crypto.key,
                                                 psa_crypto.alg,
                                                 hash,
                                                 msg.in_size[1],
                                                 signature,
                                                 msg.out_size[0],
                                                 &signature_length);

                    if (status == PSA_SUCCESS) {
                        psa_write(msg.handle, 0, signature, signature_length);
                    }

                    psa_write(msg.handle, 1,
                              &signature_length, sizeof(signature_length));
                    mbedtls_free(signature);
                    break;
                }

                case PSA_ASYMMETRIC_VERIFY: {
                    uint8_t *signature;
                    uint8_t *hash;
                    signature = mbedtls_calloc(1, msg.in_size[1]);
                    if (signature == NULL) {
                        status = PSA_ERROR_INSUFFICIENT_MEMORY;
                        break;
                    }
                    bytes_read = psa_read(msg.handle, 1,
                                          signature, msg.in_size[1]);
                    if (bytes_read != msg.in_size[1]) {
                        SPM_PANIC("SPM read length mismatch");
                    }
                    hash = mbedtls_calloc(1, msg.in_size[2]);
                    if (hash == NULL) {
                        status = PSA_ERROR_INSUFFICIENT_MEMORY;
                        break;
                    }

                    bytes_read = psa_read(msg.handle, 2,
                                          hash, msg.in_size[2]);
                    if (bytes_read != msg.in_size[2]) {
                        SPM_PANIC("SPM read length mismatch");
                    }

                    status = psa_asymmetric_verify(psa_crypto.key,
                                                   psa_crypto.alg,
                                                   hash,
                                                   msg.in_size[2],
                                                   signature,
                                                   msg.in_size[1]);
                    mbedtls_free(signature);
                    mbedtls_free(hash);
                    break;
                }

                case PSA_ASYMMETRIC_ENCRYPT:
                case PSA_ASYMMETRIC_DECRYPT: {
                    uint8_t *input;
                    uint8_t *salt;
                    uint8_t *output;
                    size_t output_length = 0;

                    uint8_t *buffer = mbedtls_calloc(1, msg.in_size[1]);
                    if (buffer == NULL) {
                        status = PSA_ERROR_INSUFFICIENT_MEMORY;
                        break;
                    }
                    bytes_read = psa_read(msg.handle, 1, buffer,
                                          msg.in_size[1]);
                    if (bytes_read != msg.in_size[1]) {
                        SPM_PANIC("SPM read length mismatch");
                    }

                    input = buffer;
                    salt = buffer + psa_crypto.input_length;

                    output = mbedtls_calloc(1, msg.out_size[0]);
                    if (output == NULL) {
                        status = PSA_ERROR_INSUFFICIENT_MEMORY;
                        mbedtls_free(buffer);
                        break;
                    }

                    if (psa_crypto.func == PSA_ASYMMETRIC_ENCRYPT)
                        status = psa_asymmetric_encrypt(psa_crypto.key,
                                                        psa_crypto.alg,
                                                        input,
                                                        psa_crypto.input_length,
                                                        salt,
                                                        psa_crypto.salt_length,
                                                        output,
                                                        msg.out_size[0],
                                                        &output_length);
                    else
                        status = psa_asymmetric_decrypt(psa_crypto.key,
                                                        psa_crypto.alg,
                                                        input,
                                                        psa_crypto.input_length,
                                                        salt,
                                                        psa_crypto.salt_length,
                                                        output,
                                                        msg.out_size[0],
                                                        &output_length);

                    if (status == PSA_SUCCESS) {
                        psa_write(msg.handle, 0, output, output_length);
                    }
                    psa_write(msg.handle, 1,
                              &output_length, sizeof(output_length));

                    mbedtls_free(output);
                    mbedtls_free(buffer);
                    break;
                }
                break;

                default:
                    status = PSA_ERROR_NOT_SUPPORTED;
            }
        }
        case PSA_IPC_DISCONNECT:
            break;

        default:
            status = PSA_ERROR_NOT_SUPPORTED;
    }
    psa_reply(msg.handle, (psa_error_t) status);
}

static void psa_aead_operation()
{
    psa_msg_t msg = { 0 };
    psa_status_t status = PSA_SUCCESS;
    psa_get(PSA_AEAD, &msg);

    switch (msg.type) {
        case PSA_IPC_CONNECT:
            break;

        case PSA_IPC_CALL: {
            if (msg.in_size[0] != sizeof(psa_crypto_ipc_aead_t)) {
                status = PSA_ERROR_COMMUNICATION_FAILURE;
                break;
            }

            uint32_t bytes_read = 0;
            psa_crypto_ipc_aead_t psa_crypto = {0};

            bytes_read = psa_read(msg.handle, 0, &psa_crypto, msg.in_size[0]);

            if (bytes_read != msg.in_size[0]) {
                SPM_PANIC("SPM read length mismatch");
            }

            switch (psa_crypto.func) {
                case PSA_AEAD_ENCRYPT:
                case PSA_AEAD_DECRYPT: {
                    uint8_t *input;
                    uint8_t *additional_data;
                    uint8_t *output;
                    size_t output_length = 0;

                    uint8_t *buffer = mbedtls_calloc(1, msg.in_size[1]);
                    if (buffer == NULL) {
                        status = PSA_ERROR_INSUFFICIENT_MEMORY;
                        break;
                    }
                    bytes_read = psa_read(msg.handle, 1, buffer,
                                          msg.in_size[1]);
                    if (bytes_read != msg.in_size[1]) {
                        SPM_PANIC("SPM read length mismatch");
                    }

                    additional_data = buffer;
                    input = buffer + psa_crypto.additional_data_length;

                    output = mbedtls_calloc(1, msg.out_size[0]);
                    if (output == NULL) {
                        mbedtls_free(buffer);
                        status = PSA_ERROR_INSUFFICIENT_MEMORY;
                        break;
                    }

                    if (psa_crypto.func == PSA_AEAD_ENCRYPT)
                        status = psa_aead_encrypt(psa_crypto.key,
                                                  psa_crypto.alg,
                                                  psa_crypto.nonce,
                                                  (size_t)psa_crypto.nonce_size,
                                                  additional_data,
                                                  psa_crypto.additional_data_length,
                                                  input,
                                                  psa_crypto.input_length,
                                                  output,
                                                  msg.out_size[0],
                                                  &output_length);
                    else
                        status = psa_aead_decrypt(psa_crypto.key,
                                                  psa_crypto.alg,
                                                  psa_crypto.nonce,
                                                  (size_t)psa_crypto.nonce_size,
                                                  additional_data,
                                                  psa_crypto.additional_data_length,
                                                  input,
                                                  psa_crypto.input_length,
                                                  output,
                                                  msg.out_size[0],
                                                  &output_length);

                    if (status == PSA_SUCCESS) {
                        psa_write(msg.handle, 0, output, output_length);
                        psa_write(msg.handle, 1,
                                  &output_length, sizeof(output_length));
                    }
                    mbedtls_free(buffer);
                    mbedtls_free(output);
                    break;
                }
                default:
                    status = PSA_ERROR_NOT_SUPPORTED;
                    break;
            }
            break;
        }
        case PSA_IPC_DISCONNECT:
            break;

        default:
            status = PSA_ERROR_NOT_SUPPORTED;
    }
    psa_reply(msg.handle, (psa_error_t) status);
}

static void psa_symmetric_operation(void)
>>>>>>> Fix the crappy crypto code
{
    if (NULL == partition) {
        SPM_PANIC("partition is NULL!\n");
    }

    partition->mutex = osMutexNew(&crypto_mutex_attr);
    if (NULL == partition->mutex) {
        SPM_PANIC("Failed to create mutex for secure partition crypto!\n");
    }

    for (uint32_t i = 0; i < CRYPTO_ROT_SRV_COUNT; ++i) {
        crypto_rot_services[i].partition = partition;
    }
    partition->rot_services = crypto_rot_services;

    partition->thread_id = osThreadNew(crypto_main, NULL, &crypto_thread_attr);
    if (NULL == partition->thread_id) {
        SPM_PANIC("Failed to create start main thread of partition crypto!\n");
    }
}
